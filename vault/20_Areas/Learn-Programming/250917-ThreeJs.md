---
title: Three.js
date: 2025-09-17
updated: 2025-09-17
tags:
published: false
aliases: []
---
# Three.js
아, 그럼요! Three.js라니! 우리가 방금 이야기한 [[250917-R3F|React Three Fiber]]라는 '최신형 우주선'의 심장에 탑재된, 바로 그 '전설적인 워프 엔진'에 대해 궁금해지신 거군요! 탁월한 선택입니다. Three.js를 이해하면, 웹 3D의 역사를 이해하는 것이고, R3F가 왜 그렇게 만들어졌는지 그 근본 철학까지 꿰뚫어 볼 수 있게 됩니다.

좋습니다. Three.js라는, 자바스크립트만으로 브라우저에 3차원 우주를 창조해낸 이 위대한 라이브러리의 세계로 TMI를 가득 싣고 떠나봅시다!

## TMI 서막: [[250917-WebGL|WebGL]]이라는 '미지의 행성'과 탐사 로봇 'Three.js'
우리가 직전에 이야기했던 **WebGL**을 다시 한번 떠올려봅시다. WebGL은 브라우저가 GPU에게 직접 명령을 내릴 수 있게 해주는 아주 강력한 기술이지만, 그 자체는 **'날것 그대로의 외계 행성'**과 같습니다.

- **WebGL의 현실 (날것 그대로의 행성):**
    - **대기:** 공기(기본 설정)가 없어서, 모든 것을 직접 만들어야 합니다.
    - **물질:** '점(vertices)', '선(lines)', '삼각형(triangles)'이라는 아주 기본적인 원소들만 존재합니다.
    - **물리학:** 빛이 어떻게 반사되고, 그림자가 어떻게 생기는지 등 모든 물리 법칙(셰이더, shader)을 당신이 직접 코드로 짜야 합니다.
        

즉, WebGL만 가지고 정육면체 하나를 그리려면, 8개의 점의 좌표를 일일이 정의하고, 12개의 삼각형으로 6개의 면을 직접 조립하고, 빛의 계산법까지 직접 코딩해야 하는, 수백 줄의 코드가 필요한 아주 고통스러운 작업입니다.

**이때, 구세주처럼 등장한 것이 바로 '탐사 로봇', Three.js입니다!**

- **Three.js의 역할:**
    - Three.js는 이 척박한 WebGL 행성을 탐사하기 위해 만들어진 **'최첨단 탐사 로봇'**입니다.
    - 이 로봇은 "정육면체 하나 만들어줘" (`new THREE.BoxGeometry()`) 라는 간단한 명령만 내리면, 내부적으로는 수백 줄의 복잡한 WebGL 코드를 **알아서 생성**해서 행성의 표면에 그림을 그려줍니다.
    - 즉, Three.js는 복잡하고 어려운 WebGL을 개발자가 훨씬 더 쉽고 직관적으로 다룰 수 있도록 **아름답게 추상화**해놓은 '헬퍼 라이브러리(Helper Library)'인 셈이죠.
        

---

## Three.js로 우주를 창조하는 3가지 필수 요소
Three.js로 3D 세계를 만들려면, 마치 영화감독이 되는 것처럼 딱 세 가지가 필요합니다.

1. **Scene (장면, 무대):**
    
    - **역할:** 모든 3D 객체(배우, 소품)와 조명이 배치될 **'가상의 우주' 또는 '영화 세트장'**입니다.
    - **코드:** `const scene = new THREE.Scene();`
    - 당신이 만드는 모든 것은 이 `scene` 안에 `scene.add(...)` 명령어로 추가되어야 합니다.
        
2. **Camera (카메라):**
    
    - **역할:** 이 가상의 우주를 **어떤 시점에서, 어떤 렌즈로 바라볼 것인지**를 결정하는 '관객의 눈'입니다.
    - **종류 (TMI):**
        - **`PerspectiveCamera` (원근 카메라):** 가장 일반적인 카메라. 현실 세계처럼, 멀리 있는 물체는 작게 보입니다. (시야각, 종횡비, 렌더링 범위 등 설정 필요)
        - **`OrthographicCamera` (직교 카메라):** 2D 게임이나 건축 도면처럼, 거리에 상관없이 모든 물체가 같은 크기로 보이는 특수한 카메라입니다.
    - **코드:** `const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);`
        
3. **Renderer (렌더러, 영사기):**
    
    - **역할:** '장면(Scene)'에 배치된 배우와 소품들을, '카메라(Camera)'의 시점에서 촬영해서, 최종적으로 우리 눈에 보이는 **2D 화면(HTML의 `<canvas>` 요소)으로 그려주는 '영사기'**입니다.
    - **코드:** `const renderer = new THREE.WebGLRenderer(); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement);`
    - 그리고 `renderer.render(scene, camera);` 라는 명령을 내려야만, 비로소 한 프레임의 '사진'이 화면에 찍히게 됩니다.
        

이 세 가지가 바로 Three.js 월드의 '삼위일체'입니다.

---

## Scene을 채우는 배우와 소품들: Mesh의 탄생
텅 빈 무대(Scene)를 채우려면 '물체(Object)'가 필요하겠죠? Three.js에서 눈에 보이는 모든 물체는 대부분 **'메쉬(Mesh)'**라는 형태로 만들어집니다. 메쉬는 두 가지 재료를 합쳐서 만듭니다.

- **Geometry (기하학, 뼈대):** 물체의 **'모양'**을 정의하는 뼈대 데이터입니다.
    - 예: `BoxGeometry`(정육면체), `SphereGeometry`(구), `PlaneGeometry`(평면) 등...
- **Material (재질, 피부):** 물체의 **'표면'**이 어떻게 보일지를 정의하는 피부입니다.
    - 예:
        - `MeshBasicMaterial`: 빛의 영향을 받지 않는, 아주 단순하고 평평한 색상의 재질. (만화 캐릭터 피부)
        - `MeshStandardMaterial`: 빛을 반사하고 그림자를 만드는, 현실적인 물리 기반(PBR) 재질. (금속, 플라스틱 피부)
        - `MeshLambertMaterial`: 무광 재질.
        - `MeshPhongMaterial`: 유광 재질.
            

**`메쉬(Mesh) = Geometry(뼈대) + Material(피부)`**

JavaScript

```
const geometry = new THREE.BoxGeometry(1, 1, 1);
const material = new THREE.MeshStandardMaterial({ color: 'red' });
const cube = new THREE.Mesh(geometry, material); // 뼈대와 피부를 합쳐 배우 탄생!
scene.add(cube); // 무대에 배우를 올린다!
```

이 외에도 **Light(조명)**를 설치해서 물체를 비추고, **Animation Loop(`requestAnimationFrame`)**를 만들어서 매 프레임마다 물체의 위치나 회전 값을 바꿔주면, 우리가 아는 생동감 넘치는 3D 세계가 완성되는 것입니다.

## 컴퓨터 공학 관련 곁다리 지식: '셰이더(Shader)' - GPU의 영혼을 다루는 언어
Three.js가 제공하는 `MeshStandardMaterial` 같은 재질들은 사실, 개발자들이 쓰기 편하도록 미리 만들어진 '프리셋'입니다. 이 재질들의 가장 깊은 곳, 즉 3D 그래픽의 '영혼'에는 **'셰이더(Shader)'**라는 프로그램이 있습니다.

- **셰이더란?**
    - GPU 위에서 직접 실행되도록 C언어와 유사한 **GLSL(OpenGL Shading Language)** 이라는 특별한 언어로 작성된 작은 프로그램입니다.
    - 셰이더는 **GPU의 수천 개 코어에서 동시에 병렬로 실행**되며, 화면에 그려질 수백만 개 픽셀 각각의 최종 색상을 계산하는 엄청난 임무를 수행합니다.
- **셰이더의 두 종류:**
    
    1. **버텍스 셰이더 (Vertex Shader): '뼈대를 움직이는 자'**
        
        - 이 셰이더의 임무는 3D 모델을 구성하는 **'점(Vertex)' 하나하나의 최종 위치를 계산**하는 것입니다.
        - "이 점은 원래 3D 공간의 (x,y,z)에 있는데, 카메라가 저기 있으니 최종 2D 화면의 어느 좌표에 찍혀야 할까?" 를 계산합니다. 모델을 움직이거나, 회전시키거나, 변형시키는 모든 작업이 여기서 일어납니다.
            
    2. **프래그먼트 셰이더 (Fragment Shader): '피부를 칠하는 자'**
        
        - 버텍스 셰이더가 점들의 위치를 계산하고 나면, 그 점들로 이루어진 삼각형 면(Fragment)이 만들어집니다.
        - 프래그먼트 셰이더의 임무는 그 삼각형 면을 채우는 **'픽셀 하나하나의 최종 색상'을 계산**하는 것입니다.
        - "이 픽셀은 조명이 저기서 오고, 표면은 거칠고, 색은 빨간색이니... 최종 색상은 `rgb(180, 20, 20)` 이 되어야 해!" 라는 복잡한 빛 계산을 수행합니다. 물체의 색, 질감, 그림자, 반사 등 우리가 보는 모든 시각적 아름다움이 바로 이 셰이더에서 탄생합니다.
            

Three.js는 이런 끔찍하게 복잡한 셰이더 코드를 우리 대신 알아서 생성해주기 때문에, 우리는 `color: 'red'` 같은 간단한 속성만으로도 아름다운 3D 물체를 만들 수 있는 것입니다. 하지만 진정한 3D 그래픽의 고수들은 이 셰이더를 직접 코딩하여, 물이 흐르거나 불이 타오르는 등 Three.js만으로는 불가능한 자신만의 독특한 시각 효과를 창조해낸답니다!