---
title: FOUC를 막는 현대적인 기술들
date: 2025-09-17
updated: 2025-09-17
tags:
  - status/evergreen
  - type/web
published: false
aliases: []
---
# [[250917-FOUC|FOUC]]를 막는 현대적인 기술들
다행히 현대 웹 개발에서는 이 어색한 깜빡임을 막을 수 있는 여러 방패들이 있습니다.

[[250917-Cause-of-FOUC|원인이 뭐드라]]
[[250917-CRP|CRP는 알고 있음?]]
### 방패 1: CSS는 `<head>`에서 (기본 중의 기본)
`<link rel="stylesheet" ...>` 태그를 항상 `<head>`의 맨 위에 두는 것이 철칙입니다. 왜냐하면 CSS는 **'렌더링 차단 리소스(Render-Blocking Resource)'**이기 때문입니다.

- **TMI:** 브라우저는 `<head>` 안에 있는 CSS 파일을 모두 다운로드하고 해석하기 전까지는, `<body>`의 어떤 내용도 화면에 그리지 않고 기다립니다. "의상이 준비되기 전까지는 배우를 무대에 올리지 않겠다!"는 브라우저 나름의 배려이자, FOUC를 막는 가장 원초적인 방법입니다.
    
### 방패 2: 서버 사이드 스타일 주입 ([[Next.js]]와 [[250918-CSS-in-JS]] 라이브러리의 협업)
최신 CSS-in-JS 라이브러리들은 Next.js와 협력하여 이 문제를 해결합니다. npm run build 시점이나 서버 렌더링 시점에, **페이지에 필요한 모든 스타일을 미리 계산해서, 완성된 <style>...</style> 태그 형태로 HTML 파일의 <head/> 안에 '박제'해서 보냅니다.

이렇게 하면 브라우저는 HTML과 CSS를 처음부터 함께 받게 되므로, 렌더링 차단 규칙에 따라 스타일이 완벽하게 준비된 상태에서 첫 화면을 그리게 되어 FOUC가 발생하지 않습니다.

### 방패 3: [['Zero-Runtime' CSS-in-JS]] (최신 트렌드)
Panda CSS, Vanilla Extract 같은 최신 라이브러리들은 아예 '런타임'에 자바스크립트가 CSS를 만드는 과정 자체를 없애버렸습니다. 빌드 시점에 모든 스타일 코드를 추출해서 **정적인 `.css` 파일**을 만들어버리죠. 그리고 이 파일을 `<head>`에 `<link>` 태그로 불러옵니다. 즉, CSS-in-JS의 편리한 개발 경험은 유지하되, 결과물은 전통적인 CSS 방식으로 되돌아가 FOUC의 원인을 원천적으로 제거하는, 두 마리 토끼를 모두 잡은 방식입니다.

[[250917-CRP-Management|더 잘 관리하는 법]]