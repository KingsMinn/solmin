---
title: "'런타임 특성'이 SSR과 만났을 때 벌어지는 비극"
date: 2025-09-17
updated: 2025-09-17
tags:
published: false
aliases: []
---
# '런타임 특성'이 SSR과 만났을 때 벌어지는 비극
자, 이제 이 '거실에서 직접 조립'하는 방식이 왜 Next.js의 SSR 환경에서 문제를 일으키는지 살펴봅시다.

1. **초기 로딩 시 깜빡임 현상 (FOUC - Flash of Unstyled Content)**
    
    - **SSR 과정:** 사용자가 페이지를 요청하면, Next.js 서버는 먼저 서버 환경에서 당신의 리액트 코드를 실행해서 **완성된 HTML '사진'**을 찍습니다. 이때 Styled Components는 이 '사진'에 필요한 스타일이 무엇인지 계산해서 `<style>` 태그 형태로 함께 보냅니다.
    - **브라우저 도착:** 브라우저는 이 'HTML 사진'과 스타일을 받아서 일단 화면에 빠르게 보여줍니다. 여기까지는 괜찮아 보이죠.
    - **문제의 '하이드레이션(Hydration)':** 이제 브라우저는 함께 받은 '레고 설명서(자바스크립트)'를 실행해서, 정적인 '사진' 위에 실제 상호작용이 가능한 리액트 앱을 덧씌웁니다. 이 과정에서 클라이언트 측의 Styled Components 라이브러리가 다시 한번 "어, 내가 조립할 스타일이 뭐지?" 하고 계산하고 스타일을 주입하기 시작합니다.
    - **결과:** 서버가 보내준 초기 스타일과, 클라이언트의 JS가 런타임에 생성하는 스타일 사이에 아주 미세한 시간 차이가 발생하면서, **스타일이 입혀지지 않은 날것의 HTML이 아주 잠깐(0.x초) 보였다가 스타일이 적용되는 '깜빡임' 현상**이 발생하는 것입니다.
        
2. **성능 저하**
    
    - **더 커진 JS 번들:** 모든 CSS 코드가 자바스크립트 파일 안에 들어가므로, 사용자가 다운로드해야 할 JS 파일의 크기가 커집니다.
    - **클라이언트 CPU 소모:** 사용자의 브라우저는 단순히 화면을 그리는 것을 넘어, 스타일을 생성하고 삽입하기 위한 **자바스크립트를 추가로 실행**해야 합니다. 즉, '레고 조립'이라는 일을 사용자의 기기(CPU)가 직접 해야 하므로, 초기 로딩 속도(Time to Interactive)가 느려질 수 있습니다.