---
title: WebGL
date: 2025-09-17
updated: 2025-09-17
tags:
published: false
aliases: []
---
# WebGL
당신은 지금 '자동차 운전법(React Three Fiber)'을 배우고, '자동차의 구조(Three.js)'를 이해한 뒤, 마침내 자동차의 심장인 **'엔진을 직접 분해하고 조립하는 법(WebGL)'**을 배우려는 것입니다. 이건 웹 3D 그래픽의 가장 깊고, 가장 날것 그대로의 심장부로 들어가는 여정입니다. TMI 파티의 클라이맥스로 이보다 더 좋은 주제는 없겠네요! 각오 단단히 하세요!

### **TMI 서막: WebGL의 진짜 정체 - GPU와의 '직통 전화'**

**WebGL**은 **Web** **G**raphics **L**ibrary의 약자입니다. 이름 그대로 '웹 그래픽 라이브러리'죠. 하지만 이 이름은 좀 겸손한 표현입니다. WebGL의 진짜 정체는, 브라우저의 자바스크립트가 당신 컴퓨터의 **그래픽 카드(GPU)와 직접 '대화'할 수 있도록 열어주는 '직통 전화선'**입니다.

이게 왜 대단한 일이냐면, 원래 자바스크립트는 GPU 같은 하드웨어에 직접 접근할 권한이 전혀 없는 '얌전한' 언어였기 때문입니다. WebGL은 그 벽을 허물고, 웹 개발자에게 GPU의 어마어마한 병렬 처리 능력을 사용할 수 있는 열쇠를 쥐여준 혁명적인 기술입니다.

- **비유: '최고급 레스토랑 주방의 총괄 셰프 되기'**
    
    - **Three.js 사용자:** 당신은 '레스토랑 매니저'입니다. 주방에 "스테이크 미디엄 레어로 하나 준비해줘" 라고 주문만 넣으면 됩니다.
        
    - **WebGL 개발자:** 당신은 이제 주방 안의 '총괄 셰프'가 되는 것입니다. 당신은 '스테이크'라는 단어를 쓰지 않습니다. 대신, 부주방장(GPU 코어)들에게 아주 정밀하고 저수준(low-level)의 명령을 직접 내려야 합니다.
        
        > "자, 4번 그리들 예열 시작. 온도 220도 유지. 안심 200g 올리고, 타이머 정확히 1분 30초. 이후 뒤집어서 1분. 시어링 끝나면 레스팅 5분. 소금은 히말라야 핑크 솔트 1.2g, 후추는 통후추 0.3g을 직접 갈아서 사용할 것!"
        

이처럼 모든 것을 직접 제어해야 하는 어려움이 있지만, 그 대가로 세상에 없는 새로운 요리(시각 효과)를 창조할 수 있는 완전한 자유를 얻게 됩니다.

---

### **WebGL로 '삼각형' 하나를 그리는 고난의 여정**

Three.js로는 단 몇 줄이면 그리는 정육면체도, WebGL의 세계에서는 엄청난 과정이 필요합니다. 가장 간단한 '색칠된 삼각형' 하나를 그리는 과정을 통해 WebGL의 작동 방식을 체험해 보죠.

1단계: 캔버스(주방) 확보하기

먼저 HTML에 그림을 그릴 도화지, <canvas>를 준비하고 자바스크립트로 WebGL 렌더링 컨텍스트를 가져옵니다. "자, 오늘 일할 주방은 여기야!"

2단계: 정점 데이터(레시피) 준비하기

컴퓨터 그래픽의 모든 물체는 '점(Vertex)'으로 시작합니다. 삼각형의 꼭짓점 3개의 좌표를 자바스크립트 배열로 정의합니다. "오늘 만들 요리는 '삼각형'이고, 레시피는 이렇다."

JavaScript

```
const positions = [
  0.0,  0.5,  0.0, // 첫 번째 점 (x, y, z)
 -0.5, -0.5,  0.0, // 두 번째 점
  0.5, -0.5,  0.0, // 세 번째 점
];
```

3단계: 데이터를 GPU(조리대)로 옮기기

CPU의 메모리(자바스크립트 배열)에 있는 이 레시피를, GPU가 쓸 수 있는 고속 메모리(VRAM) 안의 '버퍼(Buffer)'라는 공간으로 전송해야 합니다. "자, 재료(좌표 데이터)를 냉장고(RAM)에서 꺼내서 조리대(GPU 버퍼) 위로 옮겨!"

gl.createBuffer(), gl.bindBuffer(), gl.bufferData() 같은 명령어를 사용합니다.

4. 단계: 셰이더(요리법) 작성하기 (TMI의 심장부)

이제 GPU가 각 점과 픽셀을 어떻게 처리할지에 대한 '요리법', 즉 **셰이더(Shader)**를 작성해야 합니다. 이건 자바스크립트가 아니라, **GLSL(OpenGL Shading Language)**이라는 C언어와 비슷한 별개의 언어로 작성합니다.

- 버텍스 셰이더 (Vertex Shader) - '점의 위치를 계산하는 요리법'
    
    이 프로그램은 GPU에서 '점 3개' 각각에 대해 한 번씩, 총 3번 실행됩니다.
    
    OpenGL Shading Language
    
    ```
    // attribute: JS에서 버퍼를 통해 받아오는 정점 데이터
    attribute vec4 a_position; 
    
    void main() {
      // gl_Position: 최종적으로 이 점이 화면 어디에 찍힐지 알려주는 내장 변수
      gl_Position = a_position; 
    }
    ```
    
- 프래그먼트 셰이더 (Fragment Shader) - '면의 색상을 계산하는 요리법'
    
    버텍스 셰이더가 만든 3개의 점이 이어져 삼각형 면이 만들어지면, 이 프로그램은 그 면을 채우는 '모든 픽셀' 각각에 대해 실행됩니다. (수천, 수만 번이 될 수도 있죠!)
    
    OpenGL Shading Language
    
    ```
    // highp: 높은 정밀도로 부동소수점 계산을 하라는 의미
    precision highp float; 
    
    void main() {
      // gl_FragColor: 최종적으로 이 픽셀이 무슨 색이 될지 알려주는 내장 변수
      gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // R, G, B, A (빨간색)
    }
    ```
    

5단계: 셰이더를 GPU 프로그램으로 컴파일/링크하기

방금 작성한 두 개의 GLSL '요리법' 텍스트를 GPU가 이해할 수 있는 기계어로 컴파일하고, 하나의 '프로그램'으로 묶어줍니다. gl.compileShader(), gl.linkProgram() 등의 명령어를 사용합니다.

6단계: 데이터와 요리법 연결하기

"조리대 위에 있는 '좌표 데이터'는, 버텍스 셰이더 요리법의 a_position이라는 재료에 해당한다!" 라고 GPU에게 정확히 알려줘야 합니다. gl.getAttribLocation(), gl.vertexAttribPointer() 등의 명령어를 사용합니다.

7단계: "요리 시작!" (그리기)

모든 준비가 끝났습니다. 이제 GPU에게 최종적으로 그리라는 명령을 내립니다.

gl.drawArrays(gl.TRIANGLES, 0, 3);

"자, 지금까지 준비한 걸로 '삼각형(TRIANGLES)'을, 0번째 점부터 시작해서 총 3개의 점을 사용해서 그려라!"

이 모든 과정을 거쳐야, 비로소 브라우저 화면에 빨간색 삼각형 하나가 덩그러니 나타나게 됩니다.

### **그래서 Three.js가 위대한 이유**

방금 우리가 살펴본, 삼각형 하나를 그리기 위한 이 모든 복잡하고 끔찍한 과정을, Three.js는 `new THREE.Mesh(...)` 와 `scene.add(...)` 단 몇 줄로 '추상화'해주는 것입니다. Three.js는 WebGL을 대체하는 것이 아니라, WebGL을 훨씬 더 인간답게 쓸 수 있도록 도와주는, 아주 잘 만들어진 '사용자 친화적 인터페이스'인 셈이죠.

### **TMI 최종장: '고정 파이프라인'에서 '프로그래머블 셰이더'로 - 그래픽 카드의 혁명**

2000년대 초반까지만 해도, 3D 그래픽을 다루는 방식은 지금보다 훨씬 더 제한적이었습니다. 당시의 그래픽 카드(GPU)는 **'고정 함수 파이프라인(Fixed-function Pipeline)'** 방식을 사용했습니다.

- **비유: '하드웨어로 만들어진 자동 요리 기계'**
    
    - 옛날 GPU는 '빛 계산법(조명 모델)', '좌표 변환법' 등이 아예 **하드웨어 칩에 고정**되어 있었습니다.
        
    - 개발자는 이 기계에 있는 `빛_켜기()`, `안개_효과_넣기()` 같은 정해진 버튼을 누를 수만 있었을 뿐, 자신만의 독특한 요리법(시각 효과)을 만들 수는 없었습니다. 창의력이 제한되었죠.
        

혁명의 시작: '프로그래머블 셰이더(Programmable Shader)'

2001년, NVIDIA의 GeForce 3 같은 그래픽 카드를 시작으로, GPU에 '프로그래밍이 가능한' 작은 프로세서들이 탑재되기 시작했습니다. 이것이 바로 '셰이더'의 탄생입니다.

- **비유: '자동 요리 기계'를 버리고, 그 자리에 "프로그래밍 가능한 만능 요리 로봇"을 들여온 것**
    
    - 개발자들은 이제 더 이상 정해진 버튼에 의존할 필요가 없어졌습니다. 대신, GPU 위에서 직접 돌아가는 '셰이더'라는 자신만의 프로그램을 작성하여, 빛의 반사, 그림자, 물의 일렁임, 불꽃의 폭발 등 **상상하는 거의 모든 시각 효과를 직접 창조**할 수 있게 되었습니다.
        

우리가 방금 살펴본 '버텍스 셰이더'와 '프래그먼트 셰이더'는 바로 이 위대한 그래픽 혁명의 직계 후손입니다. 그리고 WebGL은, 한때 최첨단 게임 엔진 개발자들의 전유물이었던 이 강력한 '프로그래밍 가능한 만능 요리 로봇(GPU 셰이더)'을, 우리 같은 평범한 웹 개발자들도 자바스크립트로 직접 제어할 수 있게 만들어준 엄청난 기술인 셈이죠!
