---
title: Next.js의 신기방기한 캐싱 시스템
date: 2025-09-17
updated: 2025-09-17
tags:
  - status/growing
  - type/web
published: false
aliases: []
---
# Next.js의 신기방기한 캐싱 시스템
`unstable_cache`는 사실, Next.js가 제공하는 거대한 다층 캐싱 전략의 일부일 뿐입니다. Next.js는 기본적으로 '최대한 모든 것을 캐싱하여 가장 빠른 속도를 낸다'는 철학을 가지고 있습니다.

- **비유: '초고효율 레스토랑의 4단계 재고/요리 관리 시스템'**
    
1. **1단계 (요청 메모이제이션 캐시): '방금 나간 3번 테이블 주문 기억하기'**
    - `React.cache`를 통해, **단일 요청-응답 주기 내에서** 똑같은 `fetch`나 함수 호출이 여러 번 발생하면, 첫 번째 결과물을 재활용합니다.
    - "3번 테이블에 나간 '오늘의 스프'랑 똑같은 거 달라고? 주방에 또 주문 넣지 말고, 방금 만든 거 그냥 바로 드려!"
        
2. **2단계 (데이터 캐시): '오늘 쓸 재료 미리 준비해두기'**
    - 바로 **`unstable_cache`** 가 여기 해당됩니다.
    - **여러 요청에 걸쳐** 재사용될 수 있는 데이터를 미리 계산해서 보온통에 담아둡니다.
    - "오늘 특선 스프는 아침에 한 솥 끓여놓은 '보온통'에서 꺼내주자."
        
3. **3단계 (풀 라우트 캐시): '가장 잘 나가는 메뉴는 '밀키트'로 만들어두기'**
    - Next.js는 특정 페이지의 **최종 렌더링 결과물(HTML)** 을 통째로 캐싱할 수 있습니다. (SSG, ISR)
    - "어제 제일 잘 나갔던 'A코스 요리'는 아예 완제품 '밀키트'로 만들어두고, 주문 들어오면 1초 만에 내놓자."
        
4. **4단계 (라우터 캐시): '손님이 아까 본 메뉴판 기억하기'**
    - 클라이언트(브라우저) 측에서 작동합니다. 사용자가 한번 방문했던 페이지는 라우터가 캐싱해두어, 뒤로 가기/앞으로 가기 시 서버 요청 없이 즉시 보여줍니다.
    - "손님이 아까 봤던 메뉴판은 굳이 주방에서 새로 가져올 필요 없겠지."