---
title: React Three Fiber
date: 2025-09-16
updated: 2025-09-16
tags:
  - status/seed
  - type/plugin
published: false
aliases: []
---
# React Three Fiber
와! React Three Fiber! 드디어 2D 웹사이트라는 평면의 감옥을 탈출해서, **3차원 공간이라는 무한한 가능성의 우주**로 떠날 준비를 하시는군요! 정말 멋집니다. 이건 그냥 라이브러리 하나를 배우는 게 아니라, 웹 개발의 '차원'을 확장하는 엄청난 도약입니다.

'인증'이나 '파일 시스템' 같은 다소 딱딱한 주제를 넘어, 이렇게 창의적이고 시각적인 주제로 넘어오니 저도 덩달아 신나네요! 좋습니다. React Three Fiber(줄여서 R3F)가 무엇인지, 왜 필요한지, 그리고 그 밑바닥에는 어떤 경이로운 기술이 숨어있는지 TMI를 대방출해 드릴게요!

## TMI 서막: R3F는 '3D 엔진'이 아니다!
가장 먼저 깨달아야 할 사실은, React Three Fiber는 '3D 엔진'이 아니라는 것입니다. 그럼 뭘까요? R3F는 **"[[250917-ThreeJs]]라는 강력한 3D 엔진을, 우리가 사랑하는 '리액트' 방식으로 조종할 수 있게 해주는 '통역기'이자 '조종기'"**입니다.

이 문장을 이해하기 위해 두 명의 주인공을 먼저 만나보죠.

1. **Three.js:** 웹 브라우저에서 3D 그래픽을 구현하기 위한, 자바스크립트 계의 '전설적인 대장군'입니다. 아주 강력하고, 할 수 있는 것도 많지만, 성격이 좀 까다로워서 모든 것을 하나하나 명령(`const mesh = new THREE.Mesh(...)`, `scene.add(mesh)`)해줘야 합니다.
2. **React:** 우리가 잘 알다시피, "이 버튼을 저기로 옮겨!" 라고 명령하는 대신, "버튼의 목표 위치는 저기야" 라고 '상태'를 선언하면 알아서 효율적으로 처리해주는 '똑똑한 매니저'죠.
    

과거에는 이 둘을 함께 쓰기가 아주 까다로왔습니다. 리액트의 '선언적인' 세계관과 Three.js의 '명령적인' 세계관이 충돌했기 때문이죠. R3F는 바로 이 두 세계를 아름답게 이어주는 다리 역할을 하기 위해 태어났습니다.

- **비유: '레고'의 두 가지 조립 방식**
    - **Three.js 방식 (명령형):** 레고 '설명서'를 한 페이지씩 따라가는 것과 같습니다. "1. 2x4 빨간 블록을 집는다. 2. 2x2 파란 블록을 집는다. 3. 빨간 블록의 세 번째 돌기 위에 파란 블록을 꽂는다." 아주 정확하지만, 길고 지루하며, 나중에 수정하기도 어렵습니다.
    - **R3F 방식 (선언형):** '상상력'으로 레고를 조립하는 것과 같습니다. "나는 여기에 **<빨간자동차 바퀴={4개}>**가 있었으면 좋겠어." 라고 선언(컴포넌트 작성)하면, R3F가 알아서 설명서 방식의 지루한 작업들을 대신 처리해주는 겁니다.
        

---

## 두 세계의 코드, 직접 비교해보기
'회전하는 정육면체'라는 간단한 예제를 통해 두 방식의 차이를 극명하게 느껴보세요.

### 💀 전통적인 Three.js 방식
JavaScript

```
import * as THREE from 'three';

// 1. 장면, 카메라, 렌더러 등 모든 것을 수동으로 설정
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(width, height);
document.body.appendChild(renderer.domElement);

// 2. 도형과 재질을 만들고, 합쳐서 '메쉬'를 만듦
const geometry = new THREE.BoxGeometry();
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
const cube = new THREE.Mesh(geometry, material);

// 3. 장면에 직접 추가
scene.add(cube);

// 4. 애니메이션 루프를 직접 만들어서 매 프레임마다 회전 값을 변경
function animate() {
  requestAnimationFrame(animate);
  cube.rotation.x += 0.01;
  cube.rotation.y += 0.01;
  renderer.render(scene, camera);
}
animate();
```

보시다시피, 모든 것을 직접 만들고, 상태를 추적하고, 렌더링을 명령해야 합니다.

### ✨ 우아한 React Three Fiber 방식
JavaScript

```
import { Canvas, useFrame } from '@react-three/fiber';
import { useRef } from 'react';

// 1. 재사용 가능한 컴포넌트로 큐브를 정의
function SpinningCube() {
  // 2. 리액트 방식으로 3D 객체에 접근
  const meshRef = useRef();

  // 3. 매 프레임마다 실행될 로직을 훅(hook)으로 정의
  useFrame((state, delta) => {
    meshRef.current.rotation.x += delta;
  });

  // 4. JSX로 3D 씬을 '선언'한다!
  return (
    <mesh ref={meshRef}>
      <boxGeometry />
      <meshStandardMaterial color="orange" />
    </mesh>
  );
}

// 최종 렌더링
function App() {
  return (
    // Canvas가 장면, 카메라, 렌더러를 알아서 다 처리해줌!
    <Canvas>
      <ambientLight />
      <pointLight position={[10, 10, 10]} />
      <SpinningCube />
      <SpinningCube position={[-2, 0, 0]} /> {/* 컴포넌트 재사용! */}
    </Canvas>
  );
}
```

어떤가요? R3F 방식은 훨씬 간결하고, 재사용 가능하며, 리액트 개발자에게 매우 익숙합니다. `useFrame` 같은 훅을 통해 애니메이션 로직을 컴포넌트 안에 캡슐화할 수 있죠.

---

## R3F는 혼자가 아니다! - 강력한 생태계
R3F의 진짜 힘은, 함께 사용하는 수많은 '동료' 라이브러리들로부터 나옵니다.

- **`@react-three/drei`**: R3F의 '스위스 군용 칼'입니다. 카메라 조작(`OrbitControls`), 3D 모델 불러오기(`useGLTF`), 텍스트, 그림자, 온갖 도형 등, 3D 씬을 만들 때 필요한 거의 모든 잡다한 기능들을 미리 만들어진 컴포넌트로 제공합니다. 이걸 쓰면 개발 속도가 10배는 빨라집니다.
- **`@react-three/rapier`**: 3D 씬에 '물리 엔진'을 추가해줍니다. 중력, 충돌, 반동 등 실제 물리 현상을 시뮬레이션해서 사용자와 상호작용하는 동적인 씬을 만들 수 있습니다.
- **`@react-three/postprocessing`**: 3D 씬에 '인스타그램 필터' 같은 후처리 효과를 입혀줍니다. 빛 번짐(Bloom), 아웃포커싱(Depth of Field), 픽셀화 등 씬을 훨씬 더 아름답고 예술적으로 만들어주죠.
    

---

## 컴퓨터 공학 관련 곁다리 지식: 브라우저에서 3D가 어떻게 가능할까? - [[250917-WebGL|WebGL]]의 비밀
우리가 이런 멋진 3D 그래픽을 브라우저에서 볼 수 있는 근본적인 기술은 바로 **[[250917-WebGL|WebGL]](Web Graphics Library)** 입니다.

- **비유: 'CPU'와 'GPU'라는 두 명의 천재 예술가**
    - CPU (중앙 처리 장치): '만능 계획가'
        
        컴퓨터의 '뇌'인 CPU는 논리 연산, 계산, OS 관리 등 모든 것을 할 수 있는 만능 천재입니다. 하지만 한 번에 한두 가지 일만 순차적으로 처리하는 데 특화되어 있죠. 이런 CPU에게 "화면의 픽셀 200만 개의 색상을 각각 계산해!" 라고 시키면, 할 수는 있지만 아주 느릴 겁니다. 마치 소설가에게 거대한 벽화를 점 하나하나 찍어서 그리라고 시키는 것과 같죠.
        
    - GPU (그래픽 처리 장치): '병렬 처리의 괴물'
        
        그래픽카드에 들어있는 GPU는 아주 특화된 예술가입니다. 소설을 쓰진 못하지만, 수천 개의 '작은 손(코어)'을 가지고 있어서, 똑같은 단순 계산을 수천 번 동시에 처리하는 데에는 타의 추종을 불허합니다. "모든 픽셀의 색상을 빛의 각도에 맞춰 계산하라"는 명령을 받으면, 수천 개의 손이 동시에 픽셀 수천 개의 색상을 한꺼번에 계산해버리죠.
        

**WebGL은 바로, 브라우저의 자바스크립트(CPU 위에서 동작)가 이 GPU라는 괴물 예술가에게 직접 그림을 그리라고 명령을 내릴 수 있게 해주는 '통신 언어'입니다.**

이들의 관계를 최종 정리하면 이렇습니다.

> **당신(개발자)**은 **리액트(R3F)**라는 편안한 언어로 **"오렌지색 큐브를 돌려줘"**라고 선언합니다.
> 
> R3F는 이 말을 Three.js라는 전문 언어로 번역합니다.
> 
> Three.js는 이 전문 언어를 WebGL이라는 아주 저수준의 기계 언어로 번역해서 GPU에게 전달합니다.
> 
> GPU는 그 명령을 듣고, 수천 개의 손으로 미친 듯이 픽셀을 계산해서 우리 눈에 3D 큐브를 보여줍니다.

이것이 바로 우리가 지금 보고 있는 웹 3D의 경이로운 작동 원리랍니다!