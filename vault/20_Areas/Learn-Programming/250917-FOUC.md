---
title: FOUC
date: 2025-09-17
updated: 2025-09-17
tags:
  - status/seed
  - type/web
published: false
aliases: []
---
# FOUC

아! FOUC! 프론트엔드 개발자들이라면 누구나 한 번쯤 겪어봤을, 그 '어색한 깜빡임' 현상이군요. 좋습니다. 웹 페이지가 사용자 앞에서 '옷을 갈아입는' 이 부끄러운 순간이 왜 발생하는지, 그 근본적인 원인부터 최신 해결책까지 TMI를 듬뿍 담아 설명해 드릴게요.
[[250917-CRP]]의 작동방식으로 인해 깜빡임

이 질문은 우리가 이전에 나눴던 '런타임 [[CSS-in-JS]]' 이야기의 완벽한 속편과도 같습니다!

### TMI 서막: FOUC란 무엇인가? - 무대 위에 옷을 덜 입고 등장한 배우

**FOUC**는 **F**lash **o**f **U**nstyled **C**ontent의 약자로, 말 그대로 **'스타일이 적용되지 않은 콘텐츠의 깜빡임'**을 의미합니다.

- **비유: '옷을 덜 입은 채로 무대에 등장한 배우'**
    - **HTML:** 배우의 '몸'과 '대사'입니다. 내용의 골격이죠.
    - **CSS:** 배우가 입는 '의상'과 '분장'입니다. 내용의 스타일이죠.
    - **브라우저:** 연극을 총괄하는 '무대 감독'입니다.
    - **FOUC 현상:** 무대 감독(브라우저)이 너무 서두른 나머지, 아직 분장실에서 의상(CSS)을 챙겨 입고 있는 배우(HTML)를 무대 위로 밀어 올려버린 상황입니다. 관객들은 1초 동안 잠옷 차림의 배우를 보게 되고, 곧이어 의상팀 스태프가 허둥지둥 달려 나와 무대 위에서 배우에게 옷을 입히죠. 이 어색하고 프로답지 못한 순간이 바로 FOUC입니다.

---

### 1. FOUC는 왜 발생하는가? - 범인은 '지각생 CSS'

FOUC의 근본적인 원인은 단 하나입니다.

"브라우저가 HTML을 화면에 그리기 시작했는데, 그 HTML에 적용할 CSS가 아직 도착하지 않았거나 준비되지 않았을 때"

이런 'CSS 지각 사태'를 유발하는 주범들은 다음과 같습니다.

#### 범인 1: 고전적인 실수 - CSS를 `<body>` 태그 끝에 두는 경우

`<link rel="stylesheet" href="style.css">` 태그는 HTML 문서의 `<head>` 안에 쓰는 것이 약속입니다. 만약 이걸 무시하고 `<body>` 태그의 맨 끝에 두면, 브라우저는 HTML 내용물을 위에서부터 순서대로 전부 다 화면에 그린 뒤에야 "아, 맞다! 스타일시트가 있었네!" 하고 부랴부랴 CSS 파일을 불러와서 다시 그리기 시작합니다. 배우가 무대에 다 올라가고 나서야 의상을 챙기는 격이죠.

#### 범인 2: 자바스크립트로 CSS를 불러오는 경우

어떤 사이트들은 자바스크립트를 이용해서 동적으로 CSS 파일을 불러오기도 합니다. 이 경우의 작동 순서는 이렇습니다.

1. 브라우저가 HTML을 그린다.
2. 자바스크립트가 실행된다.
3. 자바스크립트가 CSS 파일을 다운로드하라고 명령한다.
4. CSS 파일이 다운로드되고 적용된다.

결국 1단계와 4단계 사이의 시간 차이 때문에 FOUC가 발생합니다. 배우가 일단 무대에 올라가서, 직접 의상실에 전화를 걸어 의상을 배달시켜 입는 것과 같습니다.

#### 범인 3: 우리가 겪었던 문제 - 런타임 CSS-in-JS ([[Styled Components]] 등)

이것이 바로 당신이 겪었던 문제입니다. Next.js SSR 환경에서 이 문제가 어떻게 발생하는지 다시 한번 복기해 보죠.
1. **서버:** HTML '사진'과 스타일을 생성하는 방법이 담긴 'JS 설명서'를 함께 보냅니다.
2. **브라우저:** 일단 받은 'HTML 사진'을 화면에 보여줍니다. (여기까지는 스타일이 적용된 상태)
3. **브라우저:** 함께 받은 'JS 설명서'를 읽기 시작합니다. (하이드레이션 시작)
4. **브라우저:** 설명서에 따라 [[Styled Components]] 라이브러리가 "나는 무슨 스타일을 만들어야 하지?" 라고 **'런타임'에 계산을 시작**하고, 계산이 끝난 CSS를 `<style>` 태그로 만들어 `<head>`에 주입합니다.

이 2단계와 4단계 사이의 미세한 간극, 즉 서버가 그려준 정적인 화면과 클라이언트의 자바스크립트가 동적으로 스타일을 제어하기 시작하는 그 찰나의 순간에 FOUC가 발생할 수 있습니다.

---

### 2. FOUC를 막는 현대적인 기술들 - 배우를 완벽하게 준비시켜 무대에 올리는 법

다행히 현대 웹 개발에서는 이 어색한 깜빡임을 막을 수 있는 여러 방패들이 있습니다.

#### 방패 1: CSS는 `<head>`에서 (기본 중의 기본)

`<link rel="stylesheet" ...>` 태그를 항상 `<head>`의 맨 위에 두는 것이 철칙입니다. 왜냐하면 CSS는 **'렌더링 차단 리소스(Render-Blocking Resource)'**이기 때문입니다.

- **TMI:** 브라우저는 `<head>` 안에 있는 CSS 파일을 모두 다운로드하고 해석하기 전까지는, `<body>`의 어떤 내용도 화면에 그리지 않고 기다립니다. "의상이 준비되기 전까지는 배우를 무대에 올리지 않겠다!"는 브라우저 나름의 배려이자, FOUC를 막는 가장 원초적인 방법입니다.
    

#### 방패 2: 서버 사이드 스타일 주입 (Next.js와 CSS-in-JS 라이브러리의 협업)

최신 CSS-in-JS 라이브러리들은 Next.js와 협력하여 이 문제를 해결합니다. npm run build 시점이나 서버 렌더링 시점에, **페이지에 필요한 모든 스타일을 미리 계산해서, 완성된 <style>...</style> 태그 형태로 HTML 파일의 <head/> 안에 '박제'해서 보냅니다.

이렇게 하면 브라우저는 HTML과 CSS를 처음부터 함께 받게 되므로, 렌더링 차단 규칙에 따라 스타일이 완벽하게 준비된 상태에서 첫 화면을 그리게 되어 FOUC가 발생하지 않습니다.

#### 방패 3: 'Zero-Runtime' CSS-in-JS (최신 트렌드)

Panda CSS, Vanilla Extract 같은 최신 라이브러리들은 아예 '런타임'에 자바스크립트가 CSS를 만드는 과정 자체를 없애버렸습니다. 빌드 시점에 모든 스타일 코드를 추출해서 **정적인 `.css` 파일**을 만들어버리죠. 그리고 이 파일을 `<head>`에 `<link>` 태그로 불러옵니다. 즉, CSS-in-JS의 편리한 개발 경험은 유지하되, 결과물은 전통적인 CSS 방식으로 되돌아가 FOUC의 원인을 원천적으로 제거하는, 두 마리 토끼를 모두 잡은 방식입니다.

---

### 컴퓨터 공학 관련 곁다리 지식: FOUC의 사촌들, '글꼴 깜빡임' 현상 (FOUT와 FOIT)

FOUC와 아주 비슷한 문제로 '웹 폰트' 때문에 발생하는 깜빡임 현상도 있습니다.
- **문제:** `Google Fonts` 같은 웹 폰트는 사용자의 컴퓨터에 없는 글꼴이므로, CSS가 "이 글꼴을 써!"라고 명령해도 브라우저는 해당 폰트 파일(`.woff2`)을 인터넷에서 다운로드해야 합니다. 그럼 폰트 파일이 다운로드되는 0.5초 동안 브라우저는 글자를 어떻게 보여줘야 할까요?
- **FOIT (Flash of Invisible Text): '투명 텍스트'의 깜빡임**
    - 과거의 몇몇 브라우저들은, 웹 폰트가 다운로드될 때까지 **아예 글자를 투명하게** 만들어버렸습니다. 사용자는 몇 초 동안 의미 없는 빈 공간만 보다가, 폰트 로딩이 끝나면 갑자기 글자가 '뿅!' 하고 나타나는 경험을 하게 됩니다.
- **FOUT (Flash of Unstyled Text): '못생긴 글꼴'의 깜빡임**
    - 요즘 대부분의 브라우저들이 사용하는 방식입니다. 일단 시스템의 기본 글꼴(굴림, 바탕, Arial 등)로 텍스트를 **먼저 보여주고**, 나중에 웹 폰트 다운로드가 끝나면 그 글꼴로 '샥'하고 교체합니다. 글자가 못생긴 글꼴에서 예쁜 글꼴로 바뀌면서 깜빡이는 현상이 발생하죠.
- 현대의 해법: font-display CSS 속성
    이제 개발자는 CSS의 font-display 속성을 통해 이 동작을 직접 제어할 수 있습니다.
    - `@font-face { font-family: 'MyFont'; src: url(...); font-display: swap; }`
    - `swap` (FOUT 방식): 가장 일반적으로 권장됩니다. 내용을 최대한 빨리 보여주는 것을 우선시합니다.
    - `block` (FOIT 방식): 짧은 시간(약 3초) 동안 텍스트를 숨깁니다.
    - `optional`: 폰트가 아주 빨리 로드되지 않으면, 그냥 기본 글꼴을 계속 사용합니다. 네트워크가 느린 사용자의 경험을 최우선으로 고려하는 방식입니다.

이처럼 프론트엔드 개발의 세계는, 사용자가 겪을 수 있는 아주 사소한 '깜빡임' 현상 하나까지도 깊이 있게 고민하고, 그것을 제어하기 위한 다양한 기술들을 발전시켜 왔답니다!